## 명령어 [ls] - 디렉토리 목록 출력

```bash

#include <stdio.h>
#include <dirent.h>

int main() {
    DIR *d;
    struct dirent *dir;
    d = opendir(".");
    if (d) {
        while ((dir = readdir(d)) != NULL) {
            printf("%s\n", dir->d_name);
        }
        closedir(d);
    } else {
        perror("opendir");
    }
    return 0;
}
```
---

## 명령어 [cd] - 디렉토리 변경

```bash

#include <stdio.h>
#include <unistd.h>

int main(int argc, char *argv[]) {
    if (argc < 2) {
        printf("사용법: %s <디렉토리>\n", argv[0]);
        return 1;
    }
    if (chdir(argv[1]) != 0) {
        perror("chdir");
        return 1;
    }
    return 0;
}
```
---

## 명령어 [pwd] - 현재 경로 출력

```bash

#include <stdio.h>
#include <unistd.h>

int main() {
    char cwd[1024];
    if (getcwd(cwd, sizeof(cwd)) != NULL) {
        printf("%s\n", cwd);
    } else {
        perror("getcwd");
    }
    return 0;
}
```
---

## 명령어 [mkdir] - 디렉토리 생성

```bash
#include <stdio.h>
#include <sys/stat.h>

int main(int argc, char *argv[]) {
    if (argc < 2) {
        printf("사용법: %s <디렉토리명>\n", argv[0]);
        return 1;
    }
    if (mkdir(argv[1], 0755) != 0) {
        perror("mkdir");
        return 1;
    }
    return 0;
}
```
---

## 명령어 [rmdir] - 디렉토리 삭제

```bash
#include <stdio.h>
#include <unistd.h>

int main(int argc, char *argv[]) {
    if (argc < 2) {
        printf("사용법: %s <디렉토리명>\n", argv[0]);
        return 1;
    }
    if (rmdir(argv[1]) != 0) {
        perror("rmdir");
        return 1;
    }
    return 0;
}
```
---

## 명령어 [rm] - 파일 삭제

```bash
#include <stdio.h>
#include <unistd.h>

int main(int argc, char *argv[]) {
    if (argc < 2) {
        printf("사용법: %s <파일명>\n", argv[0]);
        return 1;
    }
    if (unlink(argv[1]) != 0) {
        perror("unlink");
        return 1;
    }
    return 0;
}

```
---

## 명령어 [cp] - 파일 복사

```bash
#include <stdio.h>

int main(int argc, char *argv[]) {
    FILE *src, *dest;
    char buffer[1024];
    size_t bytes;

    if (argc != 3) {
        printf("사용법: %s <원본파일> <대상파일>\n", argv[0]);
        return 1;
    }

    src = fopen(argv[1], "rb");
    if (!src) {
        perror("fopen (원본)");
        return 1;
    }

    dest = fopen(argv[2], "wb");
    if (!dest) {
        perror("fopen (대상)");
        fclose(src);
        return 1;
    }

    while ((bytes = fread(buffer, 1, sizeof(buffer), src)) > 0) {
        fwrite(buffer, 1, bytes, dest);
    }

    fclose(src);
    fclose(dest);
    return 0;
}

```
---

## 명령어 [mv] - 파일 이동

```bash
#include <stdio.h>

int main(int argc, char *argv[]) {
    if (argc != 3) {
        printf("사용법: %s <기존파일명> <새파일명>\n", argv[0]);
        return 1;
    }
    if (rename(argv[1], argv[2]) != 0) {
        perror("rename");
        return 1;
    }
    return 0;
}

```

---

## 명령어 [ln] - 하드링크 생성

```bash
#include <stdio.h>
#include <unistd.h>

int main(int argc, char *argv[]) {
    if (argc != 3) {
        printf("사용법: %s <원본파일> <링크파일>\n", argv[0]);
        return 1;
    }
    if (link(argv[1], argv[2]) != 0) {
        perror("link");
        return 1;
    }
    return 0;
}


```


---

## 명령어 [find] - 하위 디렉토리에서 파일 탐색

```bash
#include <stdio.h>
#include <string.h>
#include <dirent.h>
#include <sys/stat.h>

void find(const char *dir, const char *filename) {
    DIR *dp;
    struct dirent *entry;
    struct stat statbuf;
    char path[1024];

    dp = opendir(dir);
    if (!dp) return;

    while ((entry = readdir(dp)) != NULL) {
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
            continue;

        snprintf(path, sizeof(path), "%s/%s", dir, entry->d_name);
        stat(path, &statbuf);

        if (S_ISDIR(statbuf.st_mode)) {
            find(path, filename);
        } else if (strcmp(entry->d_name, filename) == 0) {
            printf("찾음: %s\n", path);
        }
    }
    closedir(dp);
}

int main(int argc, char *argv[]) {
    if (argc != 3) {
        printf("사용법: %s <시작디렉토리> <찾을파일명>\n", argv[0]);
        return 1;
    }
    find(argv[1], argv[2]);
    return 0;
}

```

---

## 명령어 [cat] - 파일 내용 출력

```bash
#include <stdio.h>

int main(int argc, char *argv[]) {
    FILE *fp;
    char ch;

    if (argc < 2) {
        printf("사용법: %s <파일명>\n", argv[0]);
        return 1;
    }

    fp = fopen(argv[1], "r");
    if (!fp) {
        perror("fopen");
        return 1;
    }

    while ((ch = fgetc(fp)) != EOF) {
        putchar(ch);
    }

    fclose(fp);
    return 0;
}

```
---

## 명령어 [less/more] - 페이징 출력

```bash
#include <stdio.h>

int main(int argc, char *argv[]) {
    FILE *fp;
    char line[256];
    int count = 0;

    if (argc < 2) {
        printf("사용법: %s <파일명>\n", argv[0]);
        return 1;
    }

    fp = fopen(argv[1], "r");
    if (!fp) {
        perror("fopen");
        return 1;
    }

    while (fgets(line, sizeof(line), fp)) {
        printf("%s", line);
        count++;
        if (count % 10 == 0) {
            printf("-- 계속하려면 Enter --");
            getchar();
        }
    }

    fclose(fp);
    return 0;
}


```
---

## 명령어 [head] - 앞부분 출력

```bash
#include <stdio.h>

int main(int argc, char *argv[]) {
    FILE *fp;
    char line[256];
    int count = 0, lines = 10;

    if (argc < 2) {
        printf("사용법: %s <파일명> [줄 수]\n", argv[0]);
        return 1;
    }

    if (argc == 3) lines = atoi(argv[2]);
    fp = fopen(argv[1], "r");
    if (!fp) {
        perror("fopen");
        return 1;
    }

    while (fgets(line, sizeof(line), fp) && count++ < lines)
        printf("%s", line);

    fclose(fp);
    return 0;
}

```

---

## 명령어 [tail] - 끝부분 출력

```bash
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_LINES 1000

int main(int argc, char *argv[]) {
    FILE *fp;
    char *lines[MAX_LINES];
    char buffer[256];
    int count = 0, i, lines_to_show = 10;

    if (argc < 2) {
        printf("사용법: %s <파일명> [줄 수]\n", argv[0]);
        return 1;
    }

    if (argc == 3) lines_to_show = atoi(argv[2]);

    fp = fopen(argv[1], "r");
    if (!fp) {
        perror("fopen");
        return 1;
    }

    while (fgets(buffer, sizeof(buffer), fp)) {
        if (count < MAX_LINES) {
            lines[count] = strdup(buffer);
            count++;
        }
    }

    for (i = count - lines_to_show; i < count; i++) {
        if (i >= 0) printf("%s", lines[i]);
    }

    fclose(fp);
    return 0;
}

```

---

## 명령어 [grep] - 문자열 포함 줄 찾기

```bash
#include <stdio.h>
#include <string.h>

int main(int argc, char *argv[]) {
    FILE *fp;
    char line[256];

    if (argc < 3) {
        printf("사용법: %s <검색어> <파일명>\n", argv[0]);
        return 1;
    }

    fp = fopen(argv[2], "r");
    if (!fp) {
        perror("fopen");
        return 1;
    }

    while (fgets(line, sizeof(line), fp)) {
        if (strstr(line, argv[1])) {
            printf("%s", line);
        }
    }

    fclose(fp);
    return 0;
}


```

---

## 명령어 [awk] - 특정 필드 출력

```bash
#include <stdio.h>
#include <string.h>

int main(int argc, char *argv[]) {
    FILE *fp;
    char line[256];
    int field = 1;

    if (argc < 3) {
        printf("사용법: %s <필드번호> <파일명>\n", argv[0]);
        return 1;
    }

    field = atoi(argv[1]);
    fp = fopen(argv[2], "r");

    if (!fp) {
        perror("fopen");
        return 1;
    }

    while (fgets(line, sizeof(line), fp)) {
        char *token;
        int count = 1;
        token = strtok(line, " \t\n");
        while (token) {
            if (count == field) {
                printf("%s\n", token);
                break;
            }
            token = strtok(NULL, " \t\n");
            count++;
        }
    }

    fclose(fp);
    return 0;
}

```

---

## 명령어 [sed] - 문자열 치환

```bash
#include <stdio.h>
#include <string.h>

int main(int argc, char *argv[]) {
    FILE *fp;
    char line[256], *pos;
    char *target, *replacement;

    if (argc < 4) {
        printf("사용법: %s <바꿀문자열> <새문자열> <파일명>\n", argv[0]);
        return 1;
    }

    target = argv[1];
    replacement = argv[2];
    fp = fopen(argv[3], "r");

    if (!fp) {
        perror("fopen");
        return 1;
    }

    while (fgets(line, sizeof(line), fp)) {
        while ((pos = strstr(line, target)) != NULL) {
            *pos = '\0';
            printf("%s%s%s", line, replacement, pos + strlen(target));
            break;
        }
        if (!pos) printf("%s", line);
    }

    fclose(fp);
    return 0;
}

```

---

## 명령어 [sort] - 줄 정렬

```bash
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_LINES 1000

int cmpstr(const void *a, const void *b) {
    return strcmp(*(char **)a, *(char **)b);
}

int main(int argc, char *argv[]) {
    FILE *fp;
    char *lines[MAX_LINES];
    char buffer[256];
    int count = 0, i;

    if (argc < 2) {
        printf("사용법: %s <파일명>\n", argv[0]);
        return 1;
    }

    fp = fopen(argv[1], "r");
    if (!fp) {
        perror("fopen");
        return 1;
    }

    while (fgets(buffer, sizeof(buffer), fp)) {
        lines[count++] = strdup(buffer);
    }

    qsort(lines, count, sizeof(char *), cmpstr);

    for (i = 0; i < count; i++)
        printf("%s", lines[i]);

    fclose(fp);
    return 0;
}

```
---

## 명령어 [uniq] - 중복 제거

```bash
#include <stdio.h>
#include <string.h>

int main(int argc, char *argv[]) {
    FILE *fp;
    char line[256], prev[256] = "";

    if (argc < 2) {
        printf("사용법: %s <파일명>\n", argv[0]);
        return 1;
    }

    fp = fopen(argv[1], "r");
    if (!fp) {
        perror("fopen");
        return 1;
    }

    while (fgets(line, sizeof(line), fp)) {
        if (strcmp(line, prev) != 0) {
            printf("%s", line);
            strcpy(prev, line);
        }
    }

    fclose(fp);
    return 0;
}

```









